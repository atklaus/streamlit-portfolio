"""
Instantiate Dash apps.
"""
from dash_html_components.Div import Div
import matplotlib.pyplot as plt
import matplotlib.animation as animation
import numpy as np
import pandas as pd
import dash
import dash_table
import dash_html_components as html
import dash_core_components as dcc
from .layout import HTML_LAYOUT
import dash_bootstrap_components as dbc
import plotly.express as px
from dash.dependencies import Input, Output, State
import pandas as pd
from ..config import BASE_DIR
import sys
import os
from ..projects.happy_prime import HappyPrime
from ..projects.AreaOfEllipse import Point, Ellipse, OverlapOfEllipses
from ..projects.GameofLife import GameOfLife
from ..models.data_pipeline import GoogleAPI

import matplotlib.pyplot as plt


# sys.path.append(os.path.join(BASE_DIR,models)
# from ..models import google_drive_api 
# gdrive = google_drive_api.DriveAPI

############################
#Application 1
############################

def create_project1(server):
    """
    Create a Plotly Dash dashboard.
    """
    external_stylesheets = []

    dash_app = dash.Dash(__name__,
        title='Math',
        external_stylesheets=external_stylesheets,
        server=server,
        url_base_pathname='/math/'
        # routes_pathname_prefix='/project1/'
    )

    dash_app.index_string = HTML_LAYOUT

    #DONT CHANGE ANYTHING BEFORE THIS
    #NEED TO PUT INPUTS IN LIST

    dash_app.layout = html.Div(
        [
            html.H3("Happy Prime Calculator."),

            html.P("For an initial integer, consider the sum of the square of the individual digits. Continue this process and the number will either eventually equal 1 or continue in a never-ending loop. Numbers that end in a 1 are considered" + ' "Happy" numbers.'),
            html.Br(),
            html.H5("Example: 13"),
            html.H5("1\u00b2 + 3\u00b2 = 10"),
            html.H5("1\u00b2 + 0\u00b2 = 1"),

            html.Br(),
            dcc.Input(id="hp_input", type="text", placeholder="Enter an integer", debounce=True),
            html.Button('Enter', id='btn-1'),
            html.Div(id="hp_output"),
        ]
    )

    @dash_app.callback(
        Output("hp_output", "children"),
        [Input("hp_input", "value")]
    )
    def update_output(input1):
        hpObj = HappyPrime(input1)
        return hpObj.result

    if __name__ == '__main__':
        dash_app.run_server(debug=True)
    
    return dash_app.server


############################
#Applicaiton 2
############################


def create_project2(server):
    """Create a Plotly Dash dashboard."""

    external_stylesheets = []

    dash_app = dash.Dash(__name__,
        title='Project',
        external_stylesheets=external_stylesheets,
        server=server,
        routes_pathname_prefix='/project2/'
    )

    dash_app.index_string = HTML_LAYOUT


    # points_df = points_df[points_df['overlap'] == True]

    # animations = {
    #     'Scatter': px.scatter(
    #         points_df, x="x", y="y", animation_frame="group", color='overlap',
    #         animation_group="count", hover_name="count", size_max=(len(points_df)),
    #         range_x=[0,1], range_y=[0,1])
    # }

    # # EXAMPLE
    # df = px.data.gapminder()
    # animations = {
    #     'Scatter': px.scatter(
    #         points_df, x="x", y="y", animation_frame="group", color='overlap',
    #         animation_group="count", hover_name="count", size_max=(len(points_df)),
    #         range_x=[0,1], range_y=[0,1]),
    # }

    # dash_app.layout = html.Div([
    #     html.P("Select an animation:"),
    #     dcc.RadioItems(
    #         id='selection',
    #         options=[{'label': x, 'value': x} for x in animations],
    #         value='Scatter'
    #     ),
    #     dcc.Graph(id="graph"),
    # ])

    dash_app.layout = html.Div(
        [
            html.H3("Area of Overlapping Ellipses"),
            html.P("Starting with a point on the curve of an ellipse, the sum of the distance between that point and the focal points of the ellipse will be the same compared to any other point on the ellipse curve. As a result of this, the width of the ellipse will equal the sum of the distances between the focal points and a point on the curve of the ellipse."),
            html.Br(),
            html.P("With this in mind, given two ellipses, we can determine if any random point is within one of the ellipses, both of the ellipses or neither by calculating the sum of the distance between that random point and the focal points of each ellipse. This is demonstrated below by showing where random points fell. Additionally, the numbers are generated by a custom built Pseudo Random Number Generator that can use any text data to generate a random number between 0 and 1. More specifically, the generator does a Bitwise comparison of 16 pairs of characters and takes the sum product of the resulting binary list."),
            html.Br(),
            html.P("The default example is two concentric circles and the area should be close to Ï€ (Pi)."),

            html.H4("Enter inputs for Ellipse 1"),

            html.Div(children=[

                html.H5("Focal Point 1"),
                dcc.Input(id="focal_pt_1", type="text", value='0,0',className='ellipse_input'),
                html.H5("Focal Point 2"),
                dcc.Input(id="focal_pt_2", type="text", value='0,0',className='ellipse_input'),
                html.H5("Ellipse Width"),
                dcc.Input(id="width_1", type="text", value='2',className='ellipse_input'),
            ], style={'columnCount': 3}
            ),

            html.Br(),
            html.H5("Enter inputs for Ellipse 2"),
            html.Br(),

            html.Div(children=[

                html.H5("Focal Point 1"),
                dcc.Input(id="focal_pt_3", type="text", value='0,0',className='ellipse_input'),
                html.H5("Focal Point 2"),
                dcc.Input(id="focal_pt_4", type="text", value='0,0',className='ellipse_input'),
                html.H5("Ellipse Width"),
                dcc.Input(id="width_2", type="text", value='2',className='ellipse_input'),
            ], style={'columnCount': 3}
            ),

            html.Br(),
            html.H5("Random Number Iterations"),
            dcc.Input(id="n_iterations", type="text", value='5000',className='ellipse_input'),                  
            html.Button(id='submit-button-state', n_clicks=0, children='Submit'),

            # html.Br(),
            html.Div(children=[
                html.H4("Estimation of the Overlapping Area between Ellipse 1 and 2:"),            
            ], style={'columnCount': 2}),
            html.Div(children=[
                html.Div(id="overlap_area"),
            ], style={'columnCount': 2}),


            dcc.Graph(id="ellipse_plot"),
        ]
    )

    @dash_app.callback(
        [Output("ellipse_plot", "figure"),
        Output("overlap_area", "children")], 
        [Input("submit-button-state", "n_clicks")],
        [State("focal_pt_1", "value"),
        State("focal_pt_2", "value"),
        State("width_1", "value"),
        State("focal_pt_3", "value"),
        State("focal_pt_4", "value"),
        State("width_2", "value"),
        State("n_iterations", "value")])

    def update_ellipse(n_clicks,input1,input2,width1,input3,input4,width2,input5):
        if n_clicks > 0:
            x1 = int(input1.split(',')[0])
            y1 = int(input1.split(',')[1])
            x2 = int(input2.split(',')[0])
            y2 = int(input2.split(',')[1])
            x3 = int(input3.split(',')[0])
            y3 = int(input3.split(',')[1])
            x4 = int(input4.split(',')[0])
            y4 = int(input4.split(',')[1])

            p1 = Point(x1,y1)
            p2 = Point(x2,y2)
            p3 = Point(x3,y3)
            p4 = Point(x4,y4)
            e1 = Ellipse(p1,p2, int(width1))
            e2 = Ellipse(p3,p4, int(width2))

            EllObj = OverlapOfEllipses(seed = 20, iters = int(input5))
            EllObj.computeOverlapOfEllipses(e1,e2)

            points_df = EllObj.points_df.copy()
            points_df['point_number'] = range(0,len(points_df))
            ell_fig = px.scatter(
            points_df, x="x", y="y", 
            color="Location", hover_data=['point_number'])
            
            return ell_fig, EllObj.overlap_area
        else:
            ell_fig = px.scatter()
            return ell_fig, ''

    if __name__ == '__main__':
        dash_app.run_server(debug=True)
        
    return dash_app.server

def create_project3(server):
    """Create a Plotly Dash dashboard."""

    external_stylesheets = []

    dash_app = dash.Dash(__name__,
        title='Project',
        external_stylesheets=external_stylesheets,
        server=server,
        routes_pathname_prefix='/project3/'
    )

    dash_app.index_string = HTML_LAYOUT

    gdrive = GoogleAPI()
    df = gdrive.sheet_to_df("IPEDS Data", "IPEDS Data")
    df['PDI_Tier'] = df['PDI_Tier'].replace('',None)
    df['Apps_Tot_FT'] = df['Apps_Tot_FT'].replace('',None)
    df['Adm_Tot_FT'] = df['Adm_Tot_FT'].replace('',None)

    df = df.dropna()
    df['PDI_Tier']= df['PDI_Tier'].astype(float)
    df['Apps_Tot_FT']= df['Apps_Tot_FT'].astype(float)
    df['Adm_Tot_FT']= df['Adm_Tot_FT'].astype(float)


    # df = px.data.iris()
    # GameObj = GameOfLife(10, .5)
    # GameObj.advance(30)
    # data = GameObj.grids[0]
    # df = pd.DataFrame(data)


    dash_app.layout = html.Div([
        dcc.Graph(id="scatter-plot"),
        html.P("Petal Width:"),
        dcc.RangeSlider(
            id='range-slider',
            min=0, max=7, step=1,
            marks={0: '0', 2.5: '2.5'},
            value=[0, 7]
        ),
    ])

    @dash_app.callback(
        Output("scatter-plot", "figure"), 
        [Input("range-slider", "value")])
    def update_bar_chart(slider_range):
        low, high = slider_range
        mask = (df['PDI_Tier'] > low) & (df['PDI_Tier'] < high)
        fig = px.scatter(
            df[mask], x="Apps_Tot_FT", y="Adm_Tot_FT", 
            color="PDI_Tier", size='Apps_Tot_FT', 
            hover_data=['PDI_Tier'])
        return fig

    if __name__ == '__main__':
        dash_app.run_server(debug=True)
        
    return dash_app.server



