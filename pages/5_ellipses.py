import datetime
import os
import pickle
import random
import re
import time

import joblib
import numpy as np
import pandas as pd
import plotly.express as px
import requests
import streamlit as st
from bs4 import BeautifulSoup
from sklearn.preprocessing import LabelEncoder, MinMaxScaler, StandardScaler

from app.shared_ui import st_utils as stu
from shared import utils
from app.config import BASE_DIR, CREDS
from app.layout.header import page_header
from projects.ellipses import Ellipse, OverlapOfEllipses, Point


def app():
    
    stu.V_SPACE(1)

    st.subheader("Area of Overlapping Ellipses")

    st.markdown("**<u>Enter inputs for Ellipse 1</u>**", unsafe_allow_html=True)
    col1, col2, col3 = st.columns(3)
    with col1:
        focal_pt_1 = st.text_input("Focal Point 1", "1,1", key='elip_f1')
    with col2:
        focal_pt_2 = st.text_input("Focal Point 2", "1,1", key='elip_f2')
    with col3:
        width_1 = st.text_input("Ellipse Width", "2", key='elip_w1')

    st.markdown("**<u>Enter inputs for Ellipse 2</u>**", unsafe_allow_html=True)
    col4, col5, col6 = st.columns(3)
    with col4:
        focal_pt_3 = st.text_input("Focal Point 1", "1,1", key='elip_f3')
    with col5:
        focal_pt_4 = st.text_input("Focal Point 2", "1,1", key='elip_f4')
    with col6:
        width_2 = st.text_input("Ellipse Width", "2", key='elip_w2')

    col4, col5, col6 = st.columns([1,3,3])


    with col4:
        n_iterations = st.text_input("Random Number Iterations", "5000",key='elip_iters')
    submit_button = st.button("Submit",key='submit_ellipses')

    with st.expander('See Explanation'):
        st.write("""
An ellipse has two focal points. If you pick any point on the ellipse's curve and measure its distance to both focal points, the sum of those distances will be the same, no matter which point on the curve you choose. This sum is actually equal to the ellipse's width.
Now, imagine we have two ellipses. To figure out if a random point lies inside one, both, or neither of these ellipses, we just sum up its distances to the focal points of each ellipse. If the sum is less than or equal to the ellipse's width, the point is inside that ellipse.

We'll show this visually below, using random points generated by a custom Pseudo Random Number Generator. This generator uses text data to create random numbers between 0 and 1. In this case, we're using the text from 'War and Peace' to fuel the generator.

For demonstration, the default example uses two concentric circles, where the overlapping area should approximate the value of Ï€ (Pi).
        """)


    if submit_button:
        with st.spinner('Calculating...'):
            x1, y1 = map(int, focal_pt_1.split(","))
            x2, y2 = map(int, focal_pt_2.split(","))
            x3, y3 = map(int, focal_pt_3.split(","))
            x4, y4 = map(int, focal_pt_4.split(","))
            
            p1 = Point(x1, y1)
            p2 = Point(x2, y2)
            p3 = Point(x3, y3)
            p4 = Point(x4, y4)

            e1 = Ellipse(p1, p2, int(width_1))
            e2 = Ellipse(p3, p4, int(width_2))

            ell_obj = OverlapOfEllipses(seed=20, iters=int(n_iterations))
            ell_obj.computeOverlapOfEllipses(e1, e2)

            points_df = ell_obj.points_df.copy()
            points_df["point_number"] = range(0, len(points_df))

            answer = f"""
            Estimation of the Overlapping Area between Ellipse 1 and 2: 

            **{str(ell_obj.overlap_area)}**
            """ 

            st.info(answer)
            
            ell_fig = px.scatter(
                points_df, x="x", y="y", 
                color="Location", hover_data=["point_number"]
            )
            ell_fig.update_layout(legend=dict(
                orientation="h",
                yanchor="bottom",
                y=1.02,
                xanchor="right",
                x=1
            ))

            st.plotly_chart(ell_fig,use_container_width=True)

# Your existing code for page_header and other parts...
page_header('Overlapping Ellipses',page_name=os.path.basename(__file__))
app()
